<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Methods in Object-Oriented Programming (OOP)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
       
        h1 {
            color: #2c3e50;
        }
        h2 {
            color: #2980b9;
        }
        h3 {
            color: #27ae60;
        }
        
        
        ul {
            margin: 0;
            padding-left: 20px;
        }
        pre {
            background-color: #f4f4f4;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
        .note {
            background-color: #e7f3fe;
            border-left: 6px solid #2196F3;
            padding: 10px;
            margin: 20px 0;
        }
        .summary {
            background-color: #d1e7dd;
            padding: 10px;
            border-left: 5px solid #0f5132;
        }
    </style>
</head>
<body>
    <h1>Methods in Object-Oriented Programming (OOP)</h1>
    
    <p>In Object-Oriented Programming (OOP), methods are functions defined within a class that describe the behaviors or actions that objects of the class can perform. Methods are essential in OOP as they allow interaction with an object's attributes and enable the object to perform specific tasks. <strong>Reminder:</strong> Methods always need a return type (int, void, float, double).</p>

    <h2>Types of Methods in OOP</h2>

    <h3>Instance Methods</h3>
    <p><strong>Definition:</strong> These are the most common type of methods and are associated with an instance of a class (i.e., an object).</p>
    <p><strong>Usage:</strong> Instance methods can access and modify the instance variables (attributes) of the object they are called on.</p>
    <pre><code>
class Student {
    String name;
    int age;

    // Instance method
    void displayInfo() {
        System.out.println("Name: " + name);
        System.out.println("Age: " + age);
    }
}
    </code></pre>
    <p>In this example, <code>displayInfo()</code> is an instance method that prints the name and age of the Student object.</p>

    <h3>Static (Class) Methods</h3>
    <p><strong>Definition:</strong> Static methods belong to the class rather than any specific instance of the class. They are defined using the <code>static</code> keyword.</p>
    <p><strong>Usage:</strong> Static methods can be called without creating an object of the class. They can access static variables directly but cannot access instance variables.</p>
    <pre><code>
class MathOperations {
    // Static method
    static int add(int a, int b) {
        return a + b;
    }
}
    </code></pre>
    <p>The <code>add()</code> method can be called like this: <code>MathOperations.add(5, 10);</code> without needing to instantiate <code>MathOperations</code>.</p>

    <h3>Constructor Methods</h3>
    <p><strong>Definition:</strong> Constructors are special methods that are called when an object is instantiated. They initialize the object’s attributes and do not have a return type.</p>
    <p><strong>Types:</strong></p>
    <ul>
        <li><strong>Default Constructor:</strong> A constructor with no parameters.</li>
        <li><strong>Parameterized Constructor:</strong> A constructor that takes arguments to initialize the object with specific values.</li>
    </ul>
    <pre><code>
class Book {
    String title;
    int pages;

    // Parameterized Constructor
    Book(String title, int pages) {
        this.title = title;
        this.pages = pages;
    }
}
    </code></pre>
    <p>Here, the <code>Book</code> class has a parameterized constructor that sets the title and pages when an object is created.</p>

    <h3>Accessor (Getter) Methods</h3>
    <p><strong>Definition:</strong> These methods are used to retrieve the values of private instance variables.</p>
    <p><strong>Usage:</strong> Accessor methods provide a way to read the attributes of an object without directly accessing the variables.</p>
    <pre><code>
class Person {
    private String name;

    // Getter method
    public String getName() {
        return name;
    }
}
    </code></pre>
    <p>The <code>getName()</code> method allows access to the private name attribute.</p>

    <h3>Mutator (Setter) Methods</h3>
    <p><strong>Definition:</strong> These methods are used to modify the values of private instance variables.</p>
    <p><strong>Usage:</strong> Mutator methods provide controlled access to changing the attributes of an object.</p>
    <pre><code>
class Person {
    private String name;

    // Setter method
    public void setName(String name) {
        this.name = name;
    }
}
    </code></pre>
    <p>The <code>setName()</code> method allows you to set the value of the private name attribute.</p>

    <h3>Abstract Methods</h3>
    <p><strong>Definition:</strong> These are methods declared without an implementation (no method body). They are used in abstract classes and must be implemented by subclasses.</p>
    <p><strong>Usage:</strong> Abstract methods are meant to be overridden in derived classes, enforcing a contract for subclasses to provide specific behavior.</p>
    <pre><code>
abstract class Animal {
    // Abstract method
    abstract void sound();
}

class Dog extends Animal {
    // Implementing abstract method
    void sound() {
        System.out.println("Bark");
    }
}
    </code></pre>
    <p>The <code>sound()</code> method in <code>Animal</code> is abstract and is implemented by the <code>Dog</code> class.</p>

    <h3>Final Methods</h3>
    <p><strong>Definition:</strong> Methods declared with the <code>final</code> keyword cannot be overridden by subclasses.</p>
    <p><strong>Usage:</strong> Final methods ensure that the behavior defined in the method is preserved and cannot be changed in any subclass.</p>
    <pre><code>
class Car {
    // Final method
    final void startEngine() {
        System.out.println("Engine started");
    }
}
    </code></pre>
    <p>The <code>startEngine()</code> method cannot be overridden in any subclass of <code>Car</code>.</p>

    <h2>Summary</h2>
    
    <p>In OOP, methods are integral to defining the capabilities of objects. Understanding the different types of methods allows developers to design classes that are flexible, reusable, and maintainable. Each type of method serves a specific purpose, whether it’s controlling access to data, providing shared functionality, or ensuring that certain behaviors are enforced across all instances of a class.</p>

    <h1>Method Overloading in Java</h1>
    <p>Method Overloading in Java is a feature that allows a class to have more than one method with the same name, but with different parameter lists. The parameter list can vary by the number of parameters, the types of parameters, or the order of parameters. Method overloading is an example of compile-time polymorphism in Java.</p>

    <h2>Key Points of Method Overloading:</h2>
    <ul>
        <li><strong>Same Method Name, Different Parameters:</strong> Methods must have the same name but differ in the number or types of parameters (also known as the method signature).</li>
        <li><strong>Compile-time Polymorphism:</strong> The method to be called is determined at compile time based on the method signature.</li>
        <li><strong>Cannot Overload by Return Type Alone:</strong> Method overloading cannot be achieved by changing only the return type of the methods. The compiler must be able to distinguish the methods by their parameters.</li>
        <li><strong>Overloading Constructors:</strong> Constructors can also be overloaded, allowing objects to be initialized in different ways.</li>
    </ul>

    <h2>Examples of Method Overloading:</h2>

    <h3>1. Overloading by Number of Parameters:</h3>
    <pre>
class Calculator {
    // Method to add two integers
    int add(int a, int b) {
        return a + b;
    }

    // Overloaded method to add three integers
    int add(int a, int b, int c) {
        return a + b + c;
    }
}

public class Main {
    public static void main(String[] args) {
        Calculator calc = new Calculator();
        System.out.println(calc.add(10, 20));        // Outputs 30
        System.out.println(calc.add(10, 20, 30));    // Outputs 60
    }
}
    </pre>

    <h3>2. Overloading by Type of Parameters:</h3>
    <pre>
class Display {
    // Method to display an integer
    void show(int a) {
        System.out.println("Integer: " + a);
    }

    // Overloaded method to display a string
    void show(String a) {
        System.out.println("String: " + a);
    }
}

public class Main {
    public static void main(String[] args) {
        Display display = new Display();
        display.show(100);             // Outputs "Integer: 100"
        display.show("Hello, Java!");  // Outputs "String: Hello, Java!"
    }
}
    </pre>

    <h3>3. Overloading by Order of Parameters:</h3>
    <pre>
class PrintData {
    // Method to print string and integer
    void print(String s, int a) {
        System.out.println("String: " + s + ", Integer: " + a);
    }

    // Overloaded method to print integer and string
    void print(int a, String s) {
        System.out.println("Integer: " + a + ", String: " + s);
    }
}

public class Main {
    public static void main(String[] args) {
        PrintData pd = new PrintData();
        pd.print("Java", 101);    // Outputs "String: Java, Integer: 101"
        pd.print(202, "Code");    // Outputs "Integer: 202, String: Code"
    }
}
    </pre>

    <h3>4. Overloading Constructors:</h3>
    <pre>
class Box {
    double width, height, depth;

    // Constructor with no parameters
    Box() {
        width = height = depth = 0;
    }

    // Constructor with one parameter
    Box(double len) {
        width = height = depth = len;
    }

    // Constructor with three parameters
    Box(double w, double h, double d) {
        width = w;
        height = h;
        depth = d;
    }

    double volume() {
        return width * height * depth;
    }
}

public class Main {
    public static void main(String[] args) {
        Box box1 = new Box();              // Default constructor
        Box box2 = new Box(10);            // Single-parameter constructor
        Box box3 = new Box(10, 20, 30);    // Three-parameter constructor

        System.out.println("Volume of box1: " + box1.volume());  // Outputs 0.0
        System.out.println("Volume of box2: " + box2.volume());  // Outputs 1000.0
        System.out.println("Volume of box3: " + box3.volume());  // Outputs 6000.0
    }
}
    </pre>

    <div class="summary">
        <p>Method overloading is achieved at compile time, so the method signature must be distinct. It is possible to overload methods that have the same name but differ in their access modifiers or exceptions thrown. Overloaded methods can vary in their return types, but this alone is not enough to create a distinct overloaded method.</p>
    </div>
</body>
</html>
